function polarTensorGrid4d = generatePolarizability(phi,theta,Ngrid,alpha)  phiCol = reshape(phi,[Ngrid*Ngrid,1]);  thetaCol = reshape(theta,[Ngrid*Ngrid,1]);  % phi is defined as a rotation around the z axis    Rz(1,1,:) = cos(phiCol);  Rz(1,2,:) = -sin(phiCol);  Rz(1,3,:) = 0;    Rz(2,1,:) = sin(phiCol);  Rz(2,2,:) = cos(phiCol);  Rz(2,3,:) = 0;  Rz(3,1,:) = 0;  Rz(3,2,:) = 0;  Rz(3,3,:) = 1;    % theta is a rotation around the y-prime axis  Ryp(1,1,:) = cos(thetaCol);  Ryp(1,2,:) = 0;  Ryp(1,3,:) = sin(thetaCol);    Ryp(2,1,:) = 0;  Ryp(2,2,:) = 1;  Ryp(2,3,:) = 0;      Ryp(3,1,:) = -sin(thetaCol);  Ryp(3,2,:) = 0;  Ryp(3,3,:) = cos(thetaCol);  polarTensorGrid = [];%empty list to append the values into of the loop   for i=1:Ngrid^2,    for j=1:Ngrid^2,      %The polarisation tensor is a 4d matrix where each element of the matrix is represented as P_1(theta1,phi1)+P_2(theta2,phi2) where P_1 and P_2 are polarisability of the two molecules        polarTensorGrid4d(:,:,i,j) = transpose(Rz(:,:,i))*transpose(Ryp(:,:,i))*alpha*Ryp(:,:,i)*Rz(:,:,i)+transpose(Rz(:,:,j))*transpose(Ryp(:,:,j))*alpha*Ryp(:,:,j)*Rz(:,:,j);      end    end  end